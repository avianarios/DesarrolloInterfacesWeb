////Comentarios////
//Este comentario no irá en el CSS
/*Este comentario irá en el CSS, salvo que se use el modo comprimido*/
/*!Este comentario siempre irá en el CSS*/

////////////////////
////nested rules////
////////////////////
/* Nested rules allows you to organise your code in a more structured, logical and readable way by reflecting the hierarchy of HTML elements directly in the styles. This means you can write rules nested inside other rules instead of repeating selectors at every level.
Advantages:
  -Legibility: Makes it easier to understand the relationship between selectors.
  -Order: Keeps code cleaner by avoiding repetition.
  -Efficiency: Reduces writing time and makes code more manageable in large projects.
  
Be careful of not nesting too much
*/

//Example 1: basic nested selectors
nav {
  ul {
    margin: 0;
    padding: 0;
    li {
      list-style: none;
    }
  }
}

/*resulting CSS:
nav ul {
  margin: 0;
  padding: 0;
}
nav ul li {
  list-style: none;
}
nav ul li a {
  text-decoration: none;
}
*/


//Example 2: parent selector (&)
button {
  &.primary {
    background-color: blue;
  }
  &:hover {
    background-color: darkblue;
  }
}

/*resulting CSS:
button.primary {
  background-color: blue;
}

button.secondary {
  background-color: darkblue;
}*/

//Example 3: parent selector and pseudoclasses
a {
  color: blue;
  &:hover {
    color: darkblue;
  }
  &::before {
    content: '→';
    margin-right: 5px;
  }
}

/*resulting CSS:
a {
  color: blue;
}
a:hover {
  color: darkblue;
}
a::before {
  content: '→';
  margin-right: 5px;
}*/


//Example 4:  nesting properties with common prefixes
.box {
  margin: {
    top: 10px;
    bottom: 20px;
  }
  padding: {
    left: 15px;
    right: 15px;
  }
}

/*resulting CSS:
.box {
  margin-top: 10px;
  margin-bottom: 20px;
  padding-left: 15px;
  padding-right: 15px;
}*/


//Example 5: 
.button, .link {
  &--primary {
    background-color: blue;
    color: white;
  }
}

/*resulting CSS:
.button--primary {
  background-color: blue;
  color: white;
}
.link--primary {
  background-color: blue;
  color: white;
}
*/



///////////////////////
////Data structures////
///////////////////////
/*
  -Variables. They can be globals, at the beginning of the file, or locals, defined inside any class or label. Locals have preference over globals
  -Lists. Set of values accessed by index. First element = 1
  -Maps. Similar to lists, they have a key to access values
*/

////Example 1: Definición de variables globales
$color-primario: #3498db;
$tamaño-fuente: 16px;

// Uso de variables globales
body {
  font-size: $tamaño-fuente;
  background-color: $color-primario;
}

//Ejemplo 2: Definición de variables locales
// Definición de variables locales dentro de un bloque
$color-fondo: #ecf0f1;

.navbar {
  $color-fondo: #2c3e50; // Variable local, definida dentro de .navbar
  background-color: $color-fondo; // Usando la variable local
}

//Example 3: lists
$tamanyos:(40px, 80px, 160px);
.banner {
  h1{
    font-size: nth($tamanyos,2);  //Selecciono el 2º elemento de la lista tamanyos
  }
}
  
//Example 4: maps
$error:(
  "leve": 1rem,
  "medio": 2rem,
  "grave": 2.5rem
);
  
.error-leve{
  font-size: map.get($error, "leve");
}

/////////////////////
////Interpolation////
/////////////////////
//Permite insertar dinámicamente valores dentro de una cadena de texto o un selector, utilizando la sintaxis #{}
//Flexibilidad: Permite crear reglas más dinámicas basadas en valores de variables, sin necesidad de escribir cada regla manualmente.
// Reusabilidad: Puedes generar clases y selectores dinámicamente con el contenido de las variables, haciendo que tu código sea más limpio y fácil de mantener.
// Combinación de valores: Permite combinar strings y variables de forma sencilla, lo que facilita la generación de valores complejos.

//Ejemplo 1: Interplación básica en un comentario
$autor: "Chiquito de la calzada";
/*Web desarrollada por #{$autor}*/

//Ejemplo 2: Interpolación en nombres de clases o IDs
$color: 'red';

.button-#{$color} {
  background-color: $color;
}

//Ejemplo 3: Interpolación en propiedades CSS
$prefijo: 'font';
$tamaño: 'size';

#{$prefijo}-#{$tamaño} {
  font-size: 16px;
}

//Ejemplo 4: Interpolación para combinaciones de valores
$base: 'color';
$valor: 'blue';

.selector {
  background-#{$base}: $valor;
}

body{
  $color-fondo:rgb(116, 222, 246);
  background-color: variables.$color-fondo;
  color: variables.$color-texto;
}

//Ejemplo 5: Interpolación dentro de URLs:
$image-path: 'images/logo.png';

.selector{
  background-image: url('#{$image-path}');
}

////////////////////////////
////user defined modules////
////////////////////////////
/*User-defined modules allow code to be organised and reused by splitting it into smaller, more specific files. This improves the readability, modularity and maintainability of projects.

How to name module files? _miModulo.scss.  This "_" prevents sass compiler to compile this files which are intented to be imported
How to import modules? @use 'miModulo'; (no _ and no .scss)
How to use imported content?
  -@use ‘mySuperComplicatedFunctions' makes the contents of the imported file to be under a namespace based on the file name.For instance, mySuperComplicatedFunctions.variable or mySuperComplicatedFunctions.add(2,3)
  -@use ‘mySuperComplicatedFunctions' as * -> no namespace is required to access any resource. This practice is risky because it can make it harder to track the origin of a resource and may cause conflicts if resources with the same name exist in different modules.
  -@use ‘mySuperComplicatedFunctions' as 'myFunc'; -> the namespace is changed

Forwarding modules (@forward 'miModulo';) ->
  -In large projects, it is common to create a master file that gathers all modules. This simplifies the import into the main project file.
  -@forward is useful when you want to consolidate several modules into a single file, so that the other files in your project don't have to import each module individually.

Good practices using modules
  -create an index file and use @forward on
  -do not use large namespaces
  -organize modules
    -according to its purpose: variables, mixins, functions, etc.
    -according to layout: header, sidebar, main, grid, etc.
    -according to its purpose and to layout: 
      base 
      ∟_reinicio.scss -> global styles such as resets or normalisations
      ∟ _tipografia.scss
      componentes
      ∟_contenido.scss -> styles for individual components
      ∟_disposicion.scss -> styles related to the positioning of elements
      ∟_lateral.scss -> styles for secondary elements such as sidebars
      utilidades
      ∟_funciones.scss
      ∟_medios.scss
      ∟_mixins.scss
      ∟_variables.scss

What is a reset?
  a reset is a set of rules that are applied to remove the default styles that browsers automatically apply to HTML elements. Each browser has its own default stylesheet, which can cause inconsistencies in the appearance of a web page when viewed in different browsers.

  Eric meyers's reset might be one of the most famous reset


What is normalize?
  Normalize keeps some reasonable default styles, adjusting them to be consistent across browsers. It's ideal for getting started with a modern design without worrying too much about inconsistencies.
*/

//Example 1: importing modules
// _misFuncionesSuperComplicadas.scss
$primary-color: #3498db;

@mixin border-radius($radius) {
  border-radius: $radius;
}

@function darken-color($color, $amount) {
  @return darken($color, $amount);
}

//using _miModulo.scss in another file
// styles.scss
@use 'misFuncionesSuperComplicadas';

.button {
  color: misFuncionesSuperComplicadas.$primary-color;
  @include misFuncionesSuperComplicadas.border-radius(10px);
  background-color: misFuncionesSuperComplicadas.darken-color(#3498db, 10%);
}

/*Resulting CSS:
.button {
  color: #3498db;
  border-radius: 10px;
  background-color: #2980b9;
}
*/

//Example 2: avoiding using namespaces
//not recommended as this can lead to a loss of awareness of where the resource is located and can lead to conflict with resources that have the same name but belong to different modules.
@use 'misFuncionesSuperComplicadas' as *;

//Example 3: avoiding using large namespaces
@use 'misFuncionesSuperComplicadas' as 'func';

//Example 4: forwarding imported modules
// _colors.scss
$primary-color: #3498db;
$secondary-color: #2ecc71;

// _styles.scss
@forward 'colors';

// main.scss -> no need to import _colors.scss as it is importing _styles.scss wich forwards the former
@use 'styles';

.button {
  background-color: styles.$primary-color;
}


//Example 5: forwarding
// _variables.scss
$font-size: 16px;
$primary-color: #3498db;

// _mixins.scss
@mixin center {
  display: flex;
  justify-content: center;
  align-items: center;
}

// _functions.scss
@function multiply($value, $factor) {
  @return $value * $factor;
}

// _main.scss
//hay que hacer @use?

@forward 'variables';
@forward 'mixins';
@forward 'functions';

// styles.scss
@use 'main';

.container {
  font-size: main.$font-size;
  color: main.$primary-color;
  @include main.center;
  width: main.multiply(10px, 2);
}

/////////////////
////operators////
/////////////////
//Example 1: arithmetic operators: +, -, *, /, %
$base: 16px;

.container {
  font-size: $base * 1.5; // Resultado: 24px
  padding: $base / 2;     // Resultado: 8px
}


//Example 2: comparison operators: ==, !=, <, >, <=, >=
$size: 10px;

.container {
  @if $size > 5px {
    font-size: $size; // Resultado: 10px
  }
}

//Example 3: Logical operators: and, or, not

$primary-color: #3498db;
$use-color: true;

.container {
  color: if($use-color and $primary-color, $primary-color, black); // Resultado: #3498db
}

//Example 4: concat operator +
$base-color: 'color';
$variant: 'primary';

.result {
  content: $base-color + '-' + $variant; // Resultado: "color-primary"
}


//Operadores lógicos
$list-map: (success: lightgreen, alert: tomato, info: lightblue);
@mixin button-state($btn-state) {
  @if (length($list-map) > 2 and length($list-map) < 5) {
      background-color: map-get($list-map, $btn-state);
  }
}

.btn {
  @include button-state(success);
}



////////////////////////
////built-in modules////
////////////////////////

//Para usar los elementos definidos en un primer módulo en un segundo hay que usar @use en el segundo salvo en las funciones, en cuyo caso SASS es permisivo y permite usarlas en algunos casos cuando se importan a través de un archivo principal (_main.scss). Así, si se importan las funciones y el fichero que las usa en el principal, el que las usa las puede utilizar aunque no tenga @use funciones   

//Usar as * es útil cuando prefieres no agregar el prefijo del nombre del archivo o cuando necesitas importar muchas variables y no quieres escribir constantemente el nombre del módulo. Sin embargo, usar as * puede hacer que el código sea más difícil de mantener si tienes muchos archivos y variables con nombres similares, ya que no sabrás fácilmente de qué archivo proviene cada variable.
/// 
/*Sass viene con muchos módulos, organizados por categoría
    -sass:color -> generates new colors based on existing ones, making it easy to build color themes.
    -sass:list -> access and modify values in lists. They can be used to create dynamic collections like colors, sizes or menu elements
    -sass:map -> work with maps (a list of key-value pairs). They can be used to store configuration information, colors, sizes or any data that needs to be associated with a key in a map
    -sass:math -> operate on numbers.
    -sass:meta -> obtain details about Sass files and facilitate manipulation of their structure.
    -sass:selector -> allows you...
      -to create dynamic selectors
      -to analyze and modify selectors
    -sass:string -> makes it easy to combine, search, or split apart strings. They are helpful for:
      -Dynamically modifying and formatting text in your style files, such as creating CSS values from variables and transforming strings.
      -Dynamic generation of classes or ids
      -Working with paths or URLs

     
Para usar funciones incluidas en esos módulos en nuestro código, hay que invocarlo con @use "sass:módulo"

@use "sass:map";
@use "sass:math";
@use "sass:string";

*/

//Example 1: sass:color functions
@use 'sass:color';
$color: #3498db;
//adjust-color($color, $adjustment...) Permite ajustar propiedades del color, como el brillo, la saturación, la opacidad, etc. 
$adjusted-color: color.adjust($color, $lightness: 20%, $saturation: -10%);

//change-color($color, $changes...) Cambia una propiedad específica de un color, como el tono, la saturación o la opacidad, sin afectar las demás propiedades. Similar a adjust-color, pero más explícito.
$changed-color: color.change($color, $hue: 180deg, $alpha: 0.8);

//color.scale($color, $adjustments...) Escala un color, ajustando su brillo, saturación, opacidad, etc. Es útil para crear variaciones de un color base.
$scaled-color: color.scale($color, $lightness: -10%, $saturation: 15%);

//mix($color1, $color2, $weight) color.scale($color, $adjustments...) Mezcla dos colores en un porcentaje especificado. Es útil para crear transiciones suaves o combinaciones de colores.
$color2: #e74c3c;
$mixed-color: color.mix($color1, $color2, 50%);

//complement($color) Calcula el color complementario de un color dado.
$complementary-color: color.complement($color);

//grayscale($color) Convierte un color a su versión en escala de grises. Esto elimina la saturación del color, pero mantiene el brillo.
$grayscale-color: color.grayscale($color);

//invert($color, $amount) Invierte los colores en un porcentaje dado. Esto es útil para crear efectos visuales como inversiones de color en interacciones o animaciones.
$inverted-color: color.invert($color, 50%);

//rgb($red, $green, $blue) Crea un color en formato RGB a partir de valores numéricos de los componentes rojo, verde y azul. 
$color: color.rgb(52, 152, 219);

//rgba($red, $green, $blue, $alpha) Similar a rgb, pero permite especificar la opacidad del color a través de un valor de alfa (transparencia).
$color: color.rgba(52, 152, 219, 0.5);

//hsla($hue, $saturation, $lightness, $alpha) Permite crear un color en el modelo de color HSL (matiz, saturación, luminosidad) con un valor alfa para la opacidad.
$color: color.hsla(200, 100%, 50%, 0.3);


$color-primary: #3498db;
.button {
  background-color: color.scale(#$color-primary, $lightness: -30%);
}

.button:hover{
  background-color: color.scale(#$color-primary, $lightness: 10%);
}

$new-color: color.scale($color-primary, $red: 10%, $saturation: -20%);

a:visited {
  background-color: color.scale($color-primary, $red: 10%, $saturation: -20%);;
}

.button2 {
  background-color: color.adjust($color-primary, $blue: -30%, $alpha: 0.5);
}



//Example 2: sass:list functions
@use 'sass:list';

$colors: red, blue, green;

// list.length($list) Devuelve la longitud de una lista.
$number-of-colors: list.length($colors); // Resultado: 3

// list.nth($list, $n) Devuelve el elemento en la posición $n de la lista (empezando desde 1).
$second-color: list.nth($colors, 2); // Resultado: blue

// list.append($list, $value) Añade un valor al final de la lista.
$new-colors: list.append($colors, yellow); // Resultado: red, blue, green, yellow

// list.insert($list, $index, $value) Inserta un valor en la posición especificada de la lista.
$updated-colors: list.insert($colors, 2, cyan); // Resultado: red, cyan, blue, green

// list.remove($list, $index) Elimina el valor en la posición especificada de la lista.
$updated-colors: list.remove($colors, 2); // Resultado: red, green

// list.join($list, $separator) Une los elementos de la lista en una cadena, separándolos con el valor $separator.
$colors-string: list.join($colors, ', '); // Resultado: red, blue, green

// list.index($list, $value) Devuelve la posición del primer elemento en la lista que coincide con $value.
$index: list.index($colors, blue); // Resultado: 2

// list.slice($list, $start, $length) Extrae una sublista de la lista original, comenzando desde la posición $start y con una longitud de $length.
$sublist: list.slice($colors, 2, 2); // Resultado: blue, green


//Example 3: sass:map functions
$colors: (
  primary: #3498db,
  secondary: #2ecc71,
  accent: #e74c3c
);

//map.get($map, $key) Devuelve el valor asociado a la clave $key en el mapa $map.
$primary-color: map.get($colors, primary); // Resultado: #3498db

//map.set($map, $key, $value) Establece un nuevo valor en el mapa para la clave $key.
$updated-colors: map.set($colors, accent, #e74c3c);
// Resultado: (primary: #3498db, secondary: #2ecc71, accent: #e74c3c)

//map.remove($map, $key) Elimina un valor del mapa en la clave especificada $key.
$updated-colors: map.remove($colors, accent);
// Resultado: (primary: #3498db, secondary: #2ecc71)

//map.has-key($map, $key) Devuelve true si el mapa contiene la clave $key, o false si no la tiene.
$has-accent: map.has-key($colors, accent); // Resultado: false

//map.keys($map) Devuelve una lista de todas las claves en el mapa.
$keys: map.keys($colors); // Resultado: primary, secondary, accent

//map.values($map) Devuelve una lista de todos los valores del mapa.
$values: map.values($colors); // Resultado: #3498db, #2ecc71, #e74c3c

//map.merge($map1, $map2) Une dos mapas, agregando las claves y valores de $map2 a $map1.
$map1: (
  primary: #3498db,
  secondary: #2ecc71
);

$map2: (
  accent: #e74c3c,
  background: #f1f1f1
);

$merged-map: map.merge($map1, $map2); 
// Resultado: (primary: #3498db, secondary: #2ecc71, accent: #e74c3c, background: #f1f1f1)

//map.deep-remove($map, $key) Elimina recursivamente la clave especificada en todos los niveles del mapa.
$nested-map: (
  colors: (
    primary: #3498db,
    secondary: #2ecc71
  ),
  typography: (
    header: 16px,
    body: 14px
  )
);

$updated-map: map.deep-remove($nested-map, secondary);
// Resultado: (colors: (primary: #3498db), typography: (header: 16px, body: 14px))

//map.filter($map, $predicate) Filtra el mapa basándose en una función de predicado. Retorna un nuevo mapa con las claves y valores que cumplan con el predicado.
$colors: (
  primary: #3498db,
  secondary: #2ecc71,
  accent: #e74c3c
);

$filtered-map: map.filter($colors, $key, $value) {
  @return $value == #3498db;
}
// Resultado: (primary: #3498db)

//map.merge-deep($map1, $map2) Fusiona dos mapas, pero si una clave tiene un valor de mapa en ambos mapas, los valores se fusionan recursivamente.
$map1: (
  colors: (
    primary: #3498db,
    secondary: #2ecc71
  )
);

$map2: (
  colors: (
    accent: #e74c3c
  )
);

$merged-map: map.merge-deep($map1, $map2);
// Resultado: (colors: (primary: #3498db, secondary: #2ecc71, accent: #e74c3c))


$colors: red, blue, green, yellow;
$menu-items: home, about, services, contact;

.example {
  color: list.nth($colors, 2);  // Devuelve 'blue'
}

.contenedor {
  // Usamos list.length para contar los elementos de la lista
  width: list.length($menu-items) * 100px;  // Resultado: 400px
  display: grid;
  grid-template-columns: repeat(list.length($menu-items), 1fr);  // Distribuye los elementos en columnas iguales
}



//Example 4: sass:math functions
//math.div($a, $b) Realiza una división, pero de forma segura para evitar la confusión de unidades en las divisiones.
$width: 500px;
$columns: 5;
$column-width: math.div($width, $columns); // Resultado: 100px

//math.pow($base, $exponent) Calcula el valor de $base elevado a la potencia de $exponent.
$base: 2;
$exponent: 3;
$result: math.pow($base, $exponent); // Resultado: 8

//math.sqrt($number) Calcula la raíz cuadrada de un número.
$number: 16;
$square-root: math.sqrt($number); // Resultado: 4

//math.abs($number) Devuelve el valor absoluto de un número.
$number: -20;
$absolute-value: math.abs($number); // Resultado: 20

//math.min($a, $b, ...) Devuelve el valor mínimo de los números proporcionados.
$number1: 50;
$number2: 20;
$number3: 100;
$min-value: math.min($number1, $number2, $number3); // Resultado: 20

//math.max($a, $b, ...) Devuelve el valor máximo de los números proporcionados.
$number1: 50;
$number2: 20;
$number3: 100;
$max-value: math.max($number1, $number2, $number3); // Resultado: 100

//math.random($min, $max) Devuelve un número aleatorio entre los valores $min y $max (inclusive).
$min: 1;
$max: 10;
$random-value: math.random($min, $max); // Resultado: un número aleatorio entre 1 y 10

//math.round($number)Redondea el número al entero más cercano.
$number: 3.7;
$rounded: math.round($number); // Resultado: 4

//math.floor($number) Redondea el número hacia abajo al entero más cercano.
$number: 3.7;
$floored: math.floor($number); // Resultado: 3

//math.ceil($number) Redondea el número hacia arriba al entero más cercano.
$number: 3.1;
$ceiled: math.ceil($number); // Resultado: 4

//math.mod($a, $b) Devuelve el residuo de dividir $a entre $b.
$a: 17;
$b: 5;
$remainder: math.mod($a, $b); // Resultado: 2

//math.clamp($value, $min, $max) Devuelve $value si está dentro del rango definido por $min y $max. Si $value es menor que $min, devuelve $min. Si es mayor que $max, devuelve $max.
$value: 10;
$min: 5;
$max: 15;
$clamped: math.clamp($value, $min, $max); // Resultado: 10

// Si el valor estuviera fuera del rango:
$value2: 20;
$clamped2: math.clamp($value2, $min, $max); // Resultado: 15

//math.sin($angle) Calcula el seno de un ángulo en radianes.
$angle: math.div(45, 180) * math.pi; // Convertir 45 grados a radianes
$sine: math.sin($angle); // Resultado: 0.7071...

//math.cos($angle) Calcula el coseno de un ángulo en radianes.
$angle: math.div(60, 180) * math.pi; // Convertir 60 grados a radianes
$cosine: math.cos($angle); // Resultado: 0.5

//math.tan($angle) Calcula la tangente de un ángulo en radianes.
$angle: math.div(45, 180) * math.pi; // Convertir 45 grados a radianes
$tangent: math.tan($angle); // Resultado: 1


//Example 5: sass:string functions
@use 'sass:string';
$texto: "Hoy es un día maravilloso para aprender Sass";

//str-length($string) Devuelve la longitud de una cadena, es decir, el número de caracteres.
$nombre: "Juan Pérez";
$longitud: string.length($nombre);

//str-includes($string, $substring) Comprueba si una subcadena está presente en la cadena principal. Devuelve true si la subcadena está presente y false en caso contrario.
$contiene: string.str-includes($texto, "Sass");
// Resultado: true

//str-index($string, $substring) Devuelve la posición de la primera aparición de la subcadena dentro de la cadena principal. Si no se encuentra, devuelve null.
$posicion: string.str-index($texto, "día");
// Resultado: 11

//str-slice($string, $start, $end) Extrae una sección de la cadena desde la posición $start hasta la posición $end. Si no se especifica $end, extrae hasta el final de la cadena.
$parte: string.str-slice($texto, 1, 3);
// Resultado: "Hoy"

//str-replace($string, $old, $new) Reemplaza una subcadena dentro de la cadena con otra subcadena.
$nueva-frase: string.str-replace($texto, "maravilloso", "increíble");
// Resultado: "Hoy es un día increíble para aprender Sass";

//str-to-lower-case($string) Convierte todos los caracteres de la cadena a minúsculas.
$texto-minusculas: string.str-to-lower-case($texto);

//str-to-upper-case($string) Convierte todos los caracteres de la cadena a mayúsculas.
$nombre-mayusculas: string.str-to-upper-case($texto);

//str-unquote($string) Elimina las comillas de una cadena, lo que es útil cuando se trabaja con cadenas citadas.
$frase: "'Hola, mundo!'";
$sin-comillas: string.str-unquote($frase);
// Resultado: "Hola, mundo!"

//quote($string) Agrega comillas a la cadena.
@use 'sass:string';
$con-comillas: string.quote($texto);
// Resultado: "'Hoy es un día maravilloso para aprender Sass'"

//str-escape($string) Escapa caracteres especiales en una cadena de texto, lo cual es útil cuando se trabajan con valores CSS que incluyen caracteres especiales.
$texto: "Escapando la comilla: \"";
$texto-escapado: string.str-escape($texto);
// Resultado: "Escapando la comilla: \\""

//str-append($string, $suffix) Agrega una cadena al final de otra.
$completo: string.str-append($texto, ". ¡Ánimo!");
// Resultado: "Hola mundo!"

//str-insert($string, $substring, $position) Inserta una subcadena en una posición específica dentro de la cadena.
$texto: "Hola mundo";
$insertado: string.str-insert($texto, " y genial", 25);
// Resultado: "Hoy es un día maravilloso y genial para aprender Sass";



//////////////////////////
////Control structures////
//////////////////////////

//Example 1: using if-else block to define background and text color
$theme: 'dark';
header {
  @if $theme == 'dark' {
    background-color: #fff;
    color: #000;
  } @else if $theme== 'light' {
    background-color: #000;
    color: #fff;
  } @else {
    //Default theme
    background-color: #aaa;
    color: #444;
  }
}

//Example 2: another example of using if-else block to define background and text color
$modo-oscuro:true;
body{
  @if $modo-oscuro {
    color: variables.$color-texto-oscuro;
    background-color: variables.$color-fondo-oscuro;
  }
  @else {
    color: variables.$color-texto-claro;
    background-color: variables.$color-fondo-claro;
  }
}

//Example 3: using for to set each paragraph with a different color
//though includes the last value. to does not.
$colors: green, lightgreen, red, lightcoral;
@for $i from 1 through list.length($colors) {
  p:nth-of-type(#{$i}) {
    color: #f00;
    background-color: list.nth($colors, $i);
  }
}

//Example 4: using each with maps to create new classes using interpolation
//when using a map, key and value can be used
//when using a list, only value can be used
$error:(
  "leve": 1rem,
  "medio": 2rem,
  "grave": 2.5rem
);

 @each $nombre, $valor in $error {
  .error-#{$nombre} {
    font-size: $valor;
  }
}

//Example 5: Using each with maps to match users and images
$mapa: (
  pepe: "pepe.png",
  lola: "lola.png",
  manuel: "manuel.png"
);
@each $nombre, $imagen in $mapa {
  .perfil-#{$nombre} {
    background: image-url("img/#{$imagen}") no repeat;
  }
}

//Example 6: using each with lists to create new classes using iterpolation
$colors: red, green, blue;

@each $color in $colors {
  .text-#{$color} {
    color: $color;
  }
}

//Example 7: using each to iterate over a two-dimensional map
$buttons: (
  error: (#d82d2d, #666),
  success: (#52bf4a, #fff),
  warning: (#c23435, #fff)
);

.m-button {
  display: inline-block;
  padding: .5em;
  background: #ccc;
  color: #666;

  @each $name, $colors in $buttons {
    $bgcolor: nth($colors, 1);
    $fontcolor: nth($colors, 2);
    &--#{$name} {
      background-color: $bgcolor;
      color: $fontcolor;
    }  
  }
}

//Example 8: using while to set every td element with a different color
$num: 1;
$color-list:(#0f0, #00f, orange, #ccc);
@while $num < 5 {
  td:nth-child(#{$num}) {
    color: #f00;
    background-color: nth($color-list, $num);
  }
  $num: $num + 1;
}


//////////////////////
////user functions////
//////////////////////
// Se usan cuando hay que hacer algún cálculo, NO PARA REUTILIZAR CÓDIGO. Para eso están los mixins

//Example 1: converting units
@function px-to-rem($px, $base-font-size: 16px) {
  @return $px / $base-font-size * 1rem;
}

.container {
  padding: px-to-rem(32px); // Resultado: 2rem
}

.parrafo{
  padding: px-to-rem(16px);
}

//Example 2: unit scaling
@function escala-tipografica($base, $factor) {
  @return $base * $factor;
}

h1 {
  font-size: escala-tipografica(16px, 1.5); // Resultado: 24px
}

h2 {
  font-size: escala-tipografica(16px, 1.25); // Resultado: 20px
}

//Example 3: chain manipulation
@function generar-clase-color($nombre) {
  @return '.color-' + $nombre;
}

#{generar-clase-color('primario')} {
  color: #3498db;
}

#{generar-clase-color('secundario')} {
  color: #34db8a;
}

#{generar-clase-color('resalto')} {
  color: #db3434;
}

//Example 4: adding dynamic prefixes
@function add-prefix($prefix, $value) {
  @return "#{$prefix}-#{$value}";
}

// Uso
.button {
  class-name: add-prefix('btn', 'primary'); // btn-primary
}




///////////////
////Mixins/////
///////////////
//Mixins allow you to reuse the same css code in different parts by invoking it by name. They allow you to use arguments

//Example 1: simple mixin
@mixin formato-texto($tamanyo:2rem) { //Se usa un valor por defecto para el parámetro
  text-align: center;
  color: masOscuro(variables.$color-texto);
  font-weight: bold;
  font-size: $tamanyo;
}
//Aquí aplico el mixin, con un argumento, a tres etiquetas y una clase 
main, footer{
  p, .clase{
    @include formato-texto(1.25em);
  }
}

//Example 2: Media queries implemented with mixins
// _media-query.scss
@mixin mixin_media_query($size) {
  @if $size == 'p' {
    @media (max-width: 600px) {
      @content;
    }
  } @else if $size == 'm' {
    @media (min-width: 601px) and (max-width: 1024px) {
      @content;
    }
  } @else if $size == 'g' {
    @media (min-width: 1025px) {
      @content;
    }
  }
}

.texto {
  @include media-query.mixin_media_query(p) {
    color: red;
  }
  @include media-query.mixin_media_query(m) {
      color: green;
    }
  @include media-query.mixin_media_query(g) {
      color: blue;
  }
}


///////////////////
////Inheritance////
///////////////////
/*Si se quiere declarar una regla sólo para que las demás hereden de ella (lo que se llama clase abstracta en algunos lenguajes de programación), se antepone %
Para heredar de un elemento se usa @extend

Herencia vs Mixins
La herencia se usa cuando tiene sentido semánticamente que algunas clases hereden de otras como, por ejemplo, .error-grave y .error-leve podrían heredar de .error los elementos comunes
Si necesitamos usar variables, hay que usar mixins 

% is recommended to be used:
  -Avoid redundant code: If  you use a class for inheritance, with no %, a rule will be generated for that class even if it is not directly used in the HTML.
  -It is more explicit: % selectors are specifically designed to be extended, which improves readability and code organisation.

*/

//Example 1: basic inheritance
%error{  //este elemento sólo existe para que otros hereden de él
  color: red;
}

.error-leve{
  @extend %error;
  font-size: 1rem;
}

.error-grave{
  @extend %error;
  font-size: 2rem;
}


//Example 2:
// Estilo base con marcador de posición
%base-button {
  padding: 10px 20px;
  font-size: 16px;
  border: none;
  cursor: pointer;
}

// Botón primario que hereda los estilos de %base-button
.button-primary {
  @extend %base-button;
  background-color: #3498db;
  color: #fff;
}

// Botón secundario que también hereda
.button-secondary {
  @extend %base-button;
  background-color: #95a5a6;
  color: #fff;
}

/*CSS
.primary-btn, .secondary-btn {
  padding: 10px 20px;
  border-radius: 5px;
  text-align: center;
  font-size: 16px;
}

.primary-btn {
  background-color: blue;
  color: white;
}

.secondary-btn {
  background-color: grey;
  color: black;
}
*/
/////////////////////////////
////inheritance vs mixins////
/////////////////////////////

/*
Mixin:
  -Inserts the full rules in each place it is used.
  -It does not connect selectors in the final CSS; each class has its own styles.
Inheritance:
  -Groups selectors that share common rules
  -Less redundancy: Common properties are stored in a single block, reducing the size of the CSS.
  -Easier maintenance: If you need to change common properties (e.g., padding or font-size), you only have to update the placeholder %button.
  -More semantic: %button makes it clear that these properties are shared across multiple buttons.


// Selector de marcador de posición para herencia
%button {
  padding: 10px 20px;
  border-radius: 5px;
  text-align: center;
  font-size: 16px;
}

// Clases específicas que heredan de %button
.primary-btn {
  @extend %button;
  background-color: blue;
  color: white;
}

.secondary-btn {
  @extend %button;
  background-color: grey;
  color: black;
}
/*CSS resulting of the inheritanc
.primary-btn, .secondary-btn {
  padding: 10px 20px;
  border-radius: 5px;
  text-align: center;
  font-size: 16px;
}

.primary-btn {
  background-color: blue;
  color: white;
}

.secondary-btn {
  background-color: grey;
  color: black;
}*/

// Mixin para botones
@mixin button($bg-color, $color) {
  padding: 10px 20px;
  border-radius: 5px;
  text-align: center;
  font-size: 16px;
  background-color: $bg-color;
  color: $color;
}

// Uso del mixin para crear clases específicas
.primary-btn {
  @include button(blue, white);
}

.secondary-btn {
  @include button(grey, black);
}


/*CSS resulting of the mixin
 .primary-btn {
  padding: 10px 20px;
  border-radius: 5px;
  text-align: center;
  font-size: 16px;
  background-color: blue;
  color: white;
}

.secondary-btn {
  padding: 10px 20px;
  border-radius: 5px;
  text-align: center;
  font-size: 16px;
  background-color: grey;
  color: black;
}
*/